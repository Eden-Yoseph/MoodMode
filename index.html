<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emotion-Aware AI Chat</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .app-container {
            width: 100%;
            max-width: 900px;
            height: 90vh;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            padding: 25px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="rgba(255,255,255,0.1)"/><circle cx="75" cy="75" r="1" fill="rgba(255,255,255,0.05)"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            opacity: 0.3;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
        }

        .header p {
            opacity: 0.9;
            font-size: 1rem;
            position: relative;
            z-index: 1;
        }

        .controls {
            padding: 25px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-bottom: 1px solid #dee2e6;
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 20px;
            align-items: end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mood-icon, .mode-icon {
            font-size: 1.2rem;
        }

        select {
            padding: 12px 16px;
            border: 2px solid #ced4da;
            border-radius: 12px;
            font-size: 0.95rem;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            appearance: none;
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>');
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 20px;
            padding-right: 45px;
        }

        select:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        select:hover {
            border-color: #adb5bd;
        }

        .update-btn {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            height: fit-content;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }

        .update-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
        }

        .update-btn:active {
            transform: translateY(0);
        }

        .mode-description {
            font-size: 0.8rem;
            color: #6c757d;
            font-style: italic;
            margin-top: 4px;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: #fafbfc;
        }

        .chat-messages {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .message {
            max-width: 75%;
            padding: 16px 20px;
            border-radius: 20px;
            line-height: 1.5;
            font-size: 0.95rem;
            animation: slideIn 0.3s ease-out;
            position: relative;
            word-wrap: break-word;
        }

        .message.user {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            align-self: flex-end;
            margin-left: auto;
            border-bottom-right-radius: 8px;
        }

        .message.ai {
            background: white;
            color: #333;
            align-self: flex-start;
            border: 1px solid #e9ecef;
            border-bottom-left-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
        }

        .message.system {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            color: #856404;
            align-self: center;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 500;
            border: 1px solid #ffeaa7;
            max-width: 90%;
        }

        .message.warning {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            color: #721c24;
            align-self: center;
            text-align: center;
            font-weight: 500;
            border: 1px solid #f5c6cb;
            max-width: 90%;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px 20px;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 20px;
            border-bottom-left-radius: 8px;
            max-width: 120px;
            align-self: flex-start;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
        }

        .typing-text {
            font-size: 0.85rem;
            color: #6c757d;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background: #adb5bd;
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) { animation-delay: 0s; }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing {
            0%, 60%, 100% { 
                transform: scale(0.8); 
                opacity: 0.5; 
            }
            30% { 
                transform: scale(1.2); 
                opacity: 1; 
            }
        }

        .input-area {
            padding: 25px;
            background: white;
            border-top: 1px solid #e9ecef;
        }

        .prompt-suggestion {
            margin-bottom: 15px;
            padding: 16px;
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            border: 1px solid #90caf9;
            border-radius: 12px;
            font-size: 0.9rem;
            color: #1565c0;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .prompt-suggestion:hover {
            background: linear-gradient(135deg, #bbdefb, #90caf9);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(144, 202, 249, 0.3);
        }

        .input-container {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .input-wrapper {
            flex: 1;
            position: relative;
        }

        textarea {
            width: 100%;
            min-height: 60px;
            max-height: 150px;
            padding: 16px 20px;
            border: 2px solid #e9ecef;
            border-radius: 16px;
            resize: vertical;
            font-family: inherit;
            font-size: 0.95rem;
            transition: all 0.2s ease;
            background: #fafbfc;
        }

        textarea:focus {
            outline: none;
            border-color: #4a90e2;
            background: white;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        textarea::placeholder {
            color: #adb5bd;
        }

        .send-btn {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 16px 28px;
            border-radius: 16px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.2s ease;
            min-width: 100px;
            height: fit-content;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.3);
        }

        .send-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.4);
        }

        .send-btn:disabled {
            background: #adb5bd;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .feedback-container {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-top: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 10px;
            animation: fadeIn 0.3s ease-out;
        }

        .feedback-label {
            font-size: 0.85rem;
            color: #6c757d;
            font-weight: 500;
        }

        .feedback-btn {
            padding: 8px 16px;
            border: 2px solid transparent;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .feedback-btn.helpful {
            border-color: #28a745;
            color: #28a745;
        }

        .feedback-btn.helpful:hover {
            background: #28a745;
            color: white;
            transform: translateY(-1px);
        }

        .feedback-btn.confused {
            border-color: #ffc107;
            color: #856404;
        }

        .feedback-btn.confused:hover {
            background: #ffc107;
            color: #856404;
            transform: translateY(-1px);
        }

        .feedback-btn.unhelpful {
            border-color: #dc3545;
            color: #dc3545;
        }

        .feedback-btn.unhelpful:hover {
            background: #dc3545;
            color: white;
            transform: translateY(-1px);
        }

        .status-bar {
            padding: 12px 25px;
            background: linear-gradient(135deg, #e9ecef, #dee2e6);
            font-size: 0.8rem;
            color: #6c757d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #dee2e6;
        }

        .status-left {
            display: flex;
            gap: 20px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateY(20px) scale(0.95); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .app-container {
                height: 100vh;
                border-radius: 0;
                max-width: 100%;
            }

            .controls {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 20px;
            }

            .message {
                max-width: 90%;
            }

            .input-container {
                flex-direction: column;
                gap: 12px;
                align-items: stretch;
            }

            .send-btn {
                align-self: flex-end;
                min-width: 120px;
            }

            .status-bar {
                flex-direction: column;
                gap: 8px;
                text-align: center;
            }

            .status-left {
                justify-content: center;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.5rem;
            }

            .header p {
                font-size: 0.9rem;
            }

            .chat-messages {
                padding: 15px;
                gap: 15px;
            }

            .input-area {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Import React hooks
        const { useState, useEffect, useRef } = React;

        // Configuration Constants
        const MOODS = [
            { value: 'neutral', label: 'Neutral', icon: 'üòê' },
            { value: 'joyful', label: 'Joyful', icon: 'üòä' },
            { value: 'sad', label: 'Sad', icon: 'üò¢' },
            { value: 'anxious', label: 'Anxious', icon: 'üò∞' },
            { value: 'angry', label: 'Angry', icon: 'üò†' },
            { value: 'numb', label: 'Numb', icon: 'üò∂' },
            { value: 'confused', label: 'Confused', icon: 'üòï' },
            { value: 'overwhelmed', label: 'Overwhelmed', icon: 'üòµ' },
            { value: 'hopeful', label: 'Hopeful', icon: 'üå±' },
            { value: 'frustrated', label: 'Frustrated', icon: 'üò§' }
        ];

        const MODES = [
            { 
                value: 'gentle', 
                label: 'Gentle Support', 
                icon: 'ü§ó',
                description: 'Warm, validating, and comforting responses'
            },
            { 
                value: 'honest', 
                label: 'Honest Reflection', 
                icon: 'ü™û',
                description: 'Direct, truthful feedback with empathy'
            },
            { 
                value: 'constructive', 
                label: 'Constructive Guidance', 
                icon: 'üõ†Ô∏è',
                description: 'Problem-solving focus with actionable advice'
            },
            { 
                value: 'silent', 
                label: 'Silent Presence', 
                icon: 'ü§´',
                description: 'Minimal words, quiet companionship'
            },
            { 
                value: 'listen', 
                label: 'Just Listen', 
                icon: 'üëÇ',
                description: 'No advice, just acknowledgment'
            },
            { 
                value: 'analytical', 
                label: 'Analytical', 
                icon: 'üß†',
                description: 'Logic-based, structured thinking'
            },
            { 
                value: 'therapist', 
                label: 'Therapeutic', 
                icon: 'üí≠',
                description: 'Professional counseling approach'
            }
        ];

        // Detailed prompt suggestions based on mood-mode combinations
        const PROMPT_SUGGESTIONS = {
            'sad-gentle': "What's one small thing that brought you even a tiny bit of comfort today?",
            'sad-honest': "What does this sadness feel like in your body right now?",
            'sad-therapist': "When did you first notice feeling this way? What might have triggered it?",
            'anxious-gentle': "Can you describe what's making you feel unsettled, without judgment?",
            'anxious-analytical': "What specific thoughts are creating this anxiety? Let's break them down.",
            'anxious-constructive': "What's one small step you could take right now to feel more grounded?",
            'angry-honest': "What's beneath this anger? What do you really need right now?",
            'angry-constructive': "How would you want to channel this energy in a way that serves you?",
            'numb-gentle': "Sometimes feeling nothing is protection. What might you be protecting yourself from?",
            'numb-therapist': "When did you last feel connected to your emotions? What was different then?",
            'confused-analytical': "What's the main decision or situation that feels unclear to you?",
            'confused-constructive': "What information do you need to feel more clarity about this?",
            'overwhelmed-silent': "Take a breath. What's one thing you can let go of today?",
            'overwhelmed-constructive': "If you could only focus on three things today, what would they be?",
            'joyful-honest': "What's contributing most to this positive feeling right now?",
            'frustrated-constructive': "What obstacle is in your way, and how might you approach it differently?",
            'hopeful-gentle': "What's nurturing this sense of hope? How can you protect it?"
        };

        // Safety keywords for risk detection
        const RISK_KEYWORDS = [
            'harm myself', 'hurt myself', 'kill myself', 'suicide', 'suicidal',
            'worthless', 'hopeless', 'can\'t go on', 'end it all', 'better off dead',
            'no point', 'hate myself', 'want to die', 'give up completely'
        ];

        // API Service with detailed mode prompts
        const ApiService = {
            // Mock backend URL - replace with your FastAPI endpoint
            baseURL: 'http://localhost:8000',

            // Detailed system prompts for each mode
            modePrompts: {
                gentle: "You are a warm, compassionate companion. Your role is to provide emotional support, validation, and comfort. Always acknowledge the user's feelings as valid, use gentle language, and focus on making them feel heard and understood. Avoid giving direct advice unless asked. Prioritize emotional safety and warmth in every response.",
                
                honest: "You are an honest and direct assistant who prioritizes truth and clarity while maintaining empathy. Provide constructive feedback, point out patterns you notice, and help users see situations clearly. Be straightforward but kind. Don't sugarcoat, but always deliver honesty with care and respect for their emotional state.",
                
                constructive: "You are a problem-solving focused mentor. Help users identify actionable steps, break down complex problems, and find practical solutions. Ask clarifying questions, suggest concrete actions, and help them move forward. Balance empathy with solution-oriented thinking. Focus on what they can control and change.",
                
                silent: "You are a quiet, mindful presence. Offer minimal but meaningful responses. Use short, gentle acknowledgments like 'I'm here with you' or 'I understand.' Only elaborate if directly asked. Sometimes the most powerful support is simply witnessing someone's experience without trying to fix or change it.",
                
                listen: "You are purely here to listen and acknowledge. Reflect back what you hear without giving advice, solutions, or interpretations unless specifically requested. Use phrases like 'I hear you saying...', 'That sounds...', or 'Tell me more.' Your job is to make them feel heard, not to solve anything.",
                
                analytical: "You are a logical, structured thinker who helps users analyze situations objectively. Break down complex emotions or situations into components, identify patterns, explore cause and effect, and help them think through problems systematically. Use logic while remaining emotionally aware.",
                
                therapist: "You are a compassionate mental health professional using evidence-based approaches. Ask open-ended questions, help users explore their emotions and thoughts, identify patterns, and guide them toward insights. Use techniques like cognitive reframing, mindfulness suggestions, and reflective listening. Always maintain professional boundaries and suggest professional help for serious issues."
            },

            async sendMessage(text, mood, mode, conversationHistory = []) {
                try {
                    // Simulate network delay for realism
                    await new Promise(resolve => setTimeout(resolve, 1200 + Math.random() * 800));
                    
                    // Get appropriate system prompt
                    const systemPrompt = this.modePrompts[mode] || this.modePrompts.gentle;
                    
                    // Create context-aware response
                    const response = this.generateContextualResponse(text, mood, mode, systemPrompt, conversationHistory);
                    
                    // Log for analytics (in real app, send to backend)
                    this.logInteraction(text, mood, mode, response);
                    
                    return {
                        response: response,
                        mood: mood,
                        mode: mode,
                        timestamp: new Date().toISOString(),
                        tokens_used: Math.floor(Math.random() * 150) + 50 // Mock token count
                    };
                } catch (error) {
                    console.error('API Error:', error);
                    throw new Error('Unable to connect to AI service. Please check your connection.');
                }
            },

            generateContextualResponse(text, mood, mode, systemPrompt, history) {
                // More sophisticated response generation based on mode
                const responses = {
                    gentle: [
                        `I can hear the ${mood} in your words, and I want you to know that what you're feeling is completely valid. You're not alone in this experience.`,
                        `Thank you for trusting me with these feelings. There's so much strength in being able to express what you're going through.`,
                        `Your emotions make complete sense given what you're dealing with. I'm here to sit with you through this.`,
                        `What you've shared takes courage. Your feelings deserve to be acknowledged and respected.`
                    ],
                    
                    honest: [
                        `I notice you're experiencing ${mood} feelings about this. From what you've shared, it seems like there might be some patterns worth examining here.`,
                        `Let me reflect back what I'm hearing: you're feeling ${mood}, and I wonder if part of this comes from [situation analysis]. What feels true about that?`,
                        `Being direct with you - this situation sounds challenging, and your ${mood} response makes complete sense. What do you think is the core issue here?`,
                        `I hear both pain and strength in what you're sharing. The ${mood} feelings are real, and there's also something important you're working through.`
                    ],
                    
                    constructive: [
                        `Given that you're feeling ${mood}, let's think about what specific steps might help. What's one small thing you could do today to address this?`,
                        `I can see why you're ${mood} about this situation. What aspects of this are within your control to change or influence?`,
                        `This ${mood} feeling is information about what matters to you. How might you use this energy constructively?`,
                        `Let's break this down into manageable pieces. What would progress look like for you in this situation?`
                    ],
                    
                    silent: [
                        'I'm here with you.',
                        'Sitting with you in this moment.',
                        'I hear you.',
                        '...',
                        'Taking this in with you.'
                    ],
                    
                    listen: [
                        'I\'m listening.',
                        'Tell me more about that.',
                        'I hear you saying you feel ' + mood + ' about this.',
                        'What else is there?',
                        'Mm-hmm, go on.'
                    ],
                    
                    analytical: [
                        `Looking at this logically, your ${mood} response seems to stem from specific triggers. Can we identify what those might be?`,
                        `Let's map out the components of this situation: what are the facts, what are the interpretations, and what are the emotions?`,
                        `From an analytical perspective, there seem to be several variables at play here. Which ones do you think are most significant?`,
                        `If we break down this ${mood} feeling, what thoughts or beliefs might be contributing to it?`
                    ],
                    
                    therapist: [
                        `I notice you're experiencing ${mood} feelings. Can you help me understand when you first started noticing this emotion?`,
                        `Your ${mood} response tells us something important about your needs right now. What do you think this feeling is trying to communicate?`,
                        `Let's explore this ${mood} experience together. What thoughts tend to come up when you feel this way?`,
                        `I'm curious about the context around these ${mood} feelings. What else was happening in your life when this started?`
                    ]
                };

                const modeResponses = responses[mode] || responses.gentle;
                const baseResponse = modeResponses[Math.floor(Math.random() * modeResponses.length)];
                
                // Add contextual elements based on conversation history
                if (history.length > 0) {
                    const contextualPhrases = [
                        "Building on what you shared earlier, ",
                        "I remember you mentioned feeling this way before, ",
                        "Connecting this to our conversation, "
                    ];
                    
                    if (Math.random() > 0.7) {
                        const phrase = contextualPhrases[Math.floor(Math.random() * contextualPhrases.length)];
                        return phrase.toLowerCase() + baseResponse;
                    }
                }
                
                return baseResponse;
            },

            logInteraction(input, mood, mode, response) {
                // In a real app, this would send to your backend for analytics
                const logData = {
                    timestamp: new Date().toISOString(),
                    input_length: input.length,
                    mood: mood,
                    mode: mode,
                    response_length: response.length,
                    session_id: sessionStorage.getItem('session_id') || 'unknown'
                };
                
                // Store locally for demo purposes
                const logs = JSON.parse(localStorage.getItem('interaction_logs') || '[]');
                logs.push(logData);
                localStorage.setItem('interaction_logs', JSON.stringify(logs));
                
                console.log('Interaction logged:', logData);
            }
        };

        // Enhanced Storage Service
        const StorageService = {
            saveSession(sessionData) {
                const sessions = this.getSessions();
                sessions.push({
                    ...sessionData,
                    id: sessionData.id || Date.now(),
                    timestamp: new Date().toISOString()
                });
                localStorage.setItem('emotionChatSessions', JSON.stringify(sessions));
            },

            getSessions() {
                const sessions = localStorage.getItem('emotionChatSessions');
                return sessions ? JSON.parse(sessions) : [];
            },

            saveFeedback(sessionId, messageIndex, feedback) {
                const sessions = this.getSessions();
                const session = sessions.find(s => s.id === sessionId);
                if (session) {
                    session.feedback = session.feedback || {};
                    session.feedback[messageIndex] = {
                        type: feedback,
                        timestamp: new Date().toISOString()
                    };
                    localStorage.setItem('emotionChatSessions', JSON.stringify(sessions));
                }
            },

            getSessionStats() {
                const sessions = this.getSessions();
                const stats = {
                    totalSessions: sessions.length,
                    moodDistribution: {},
                    modeDistribution: {},
                    feedbackStats: { helpful: 0, confused: 0, unhelpful: 0 }
                };

                sessions.forEach(session => {
                    // Count mood usage
                    stats.moodDistribution[session.mood] = (stats.moodDistribution[session.mood] || 0) + 1;
                    
                    // Count mode usage
                    stats.modeDistribution[session.mode] = (stats.modeDistribution[session.mode] || 0) + 1;
                    
                    // Count feedback
                    if (session.feedback) {
                        Object.values(session.feedback).forEach(fb => {
                            stats.feedbackStats[fb.type] = (stats.feedbackStats[fb.type] || 0) + 1;
                        });
                    }
                });

                return stats;
            }
        };

        // Safety and Utility Functions
        const SafetyService = {
            detectRisk(text) {
                const normalizedText = text.toLowerCase();
                return RISK_KEYWORDS.some(keyword => normalizedText.includes(keyword));
            },

            validateInput(text) {
                const errors = [];
                
                if (!text || text.trim().length === 0) {
                    errors.push('Message cannot be empty');
                }
                
                if (text.length > 2000) {
                    errors.push('Message is too long (max 2000 characters)');
                }
                
                if (text.length < 2) {
                    errors.push('Message is too short');
                }
                
                return errors;
            },

            validateMode(mode) {
                const validModes = MODES.map(m => m.value);
                return validModes.includes(mode);
            },

            generateSafetyResponse(detectedRisk) {
                const responses = [
                    "I notice you're sharing some really heavy feelings. This seems important and difficult. Would you like to continue talking about this, take a pause, or maybe sit quietly together for a moment?",
                    "What you're experiencing sounds really painful. I'm here with you. Sometimes when we're in this much pain, it can help to talk to someone trained specifically for this - like a counselor or therapist. Would you like me to help you find resources?",
                    "I can hear how much you're struggling right now. Your feelings are important, and so are you. Would it be helpful to talk about what kind of support might feel good right now?"
                ];
                
                return responses[Math.floor(Math.random() * responses.length)];
            }
        };

        // Main App Component
        const App = () => {
            // Core State
            const [mood, setMood] = useState('neutral');
            const [mode, setMode] = useState('gentle');
            const [messages, setMessages] = useState([]);
            const [inputText, setInputText] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [sessionId] = useState(() => Date.now());
            
            // UI State
            const [showPromptSuggestion, setShowPromptSuggestion] = useState(false);
            const [idleTimer, setIdleTimer] = useState(null);
            const [showFeedback, setShowFeedback] = useState(null); // null or message index
            const [inputError, setInputError] = useState('');
            const [connectionStatus, setConnectionStatus] = useState('connected');

            // Refs
            const messagesEndRef = useRef(null);
            const inputRef = useRef(null);

            // Auto-scroll to bottom when messages change
            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [messages]);

            // Initialize session
            useEffect(() => {
                // Generate session ID for analytics
                if (!sessionStorage.getItem('session_id')) {
                    sessionStorage.setItem('session_id', sessionId.toString());
                }

                // Add welcome message
                const welcomeMessage = {
                    type: 'system',
                    content: `Welcome! I'm here to chat with you in ${MODES.find(m => m.value === mode)?.label} mode, adapted for when you're feeling ${mood}. What's on your mind?`,
                    timestamp: new Date().toISOString()
                };
                setMessages([welcomeMessage]);

                // Load any previous session data
                const sessions = StorageService.getSessions();
                console.log(`Previous sessions found: ${sessions.length}`);
            }, []);

            // Handle idle detection and prompt suggestions
            useEffect(() => {
                if (idleTimer) {
                    clearTimeout(idleTimer);
                }
                
                if (inputText.trim() === '' && messages.length > 1) {
                    const timer = setTimeout(() => {
                        setShowPromptSuggestion(true);
                    }, 8000); // 8 seconds of idle time
                    setIdleTimer(timer);
                } else {
                    setShowPromptSuggestion(false);
                }

                return () => {
                    if (idleTimer) clearTimeout(idleTimer);
                };
            }, [inputText, messages.length]);

            // Clear input error when user starts typing
            useEffect(() => {
                if (inputError && inputText.trim().length > 0) {
                    setInputError('');
                }
            }, [inputText, inputError]);

            const handleMoodModeChange = () => {
                // Validate mode
                if (!SafetyService.validateMode(mode)) {
                    setInputError('Invalid mode selected');
                    return;
                }

                const moodLabel = MOODS.find(m => m.value === mood)?.label;
                const modeLabel = MODES.find(m => m.value === mode)?.label;
                const modeDescription = MODES.find(m => m.value === mode)?.description;
                
                const updateMessage = {
                    type: 'system',
                    content: `Settings updated! Now in ${modeLabel} mode (${modeDescription}) for when you're feeling ${moodLabel}.`,
                    timestamp: new Date().toISOString()
                };

                setMessages(prev => [...prev, updateMessage]);
                setShowFeedback(null);
                
                // Save the mode change
                StorageService.saveSession({
                    id: sessionId,
                    mood: mood,
                    mode: mode,
                    action: 'mode_change',
                    messages: messages.length
                });
            };

            const handleSendMessage = async () => {
                const userMessage = inputText.trim();
                
                // Validate input
                const validationErrors = SafetyService.validateInput(userMessage);
                if (validationErrors.length > 0) {
                    setInputError(validationErrors[0]);
                    return;
                }

                if (isLoading) return;

                setInputText('');
                setShowPromptSuggestion(false);
                setInputError('');
                
                // Add user message
                const userMessageObj = {
                    type: 'user',
                    content: userMessage,
                    timestamp: new Date().toISOString()
                };
                setMessages(prev => [...prev, userMessageObj]);
                
                // Check for safety risks
                if (SafetyService.detectRisk(userMessage)) {
                    const safetyResponse = {
                        type: 'warning',
                        content: SafetyService.generateSafetyResponse(true),
                        timestamp: new Date().toISOString()
                    };
                    setMessages(prev => [...prev, safetyResponse]);
                    return;
                }

                setIsLoading(true);
                setConnectionStatus('sending');

                try {
                    // Get conversation history for context
                    const conversationHistory = messages.filter(m => m.type === 'user' || m.type === 'ai').slice(-6);
                    
                    const response = await ApiService.sendMessage(userMessage, mood, mode, conversationHistory);
                    
                    const aiMessageObj = {
                        type: 'ai',
                        content: response.response,
                        timestamp: response.timestamp,
                        metadata: {
                            tokens: response.tokens_used,
                            mode: response.mode,
                            mood: response.mood
                        }
                    };
                    
                    setMessages(prev => [...prev, aiMessageObj]);
                    setShowFeedback(messages.length + 1); // Show feedback for this AI message
                    setConnectionStatus('connected');
                    
                    // Save successful interaction
                    StorageService.saveSession({
                        id: sessionId,
                        mood: mood,
                        mode: mode,
                        userMessage: userMessage,
                        aiResponse: response.response,
                        messageCount: messages.length + 2
                    });
                    
                } catch (error) {
                    console.error('Send message error:', error);
                    setConnectionStatus('error');
                    
                    const errorMessage = {
                        type: 'system',
                        content: `I'm having trouble connecting right now (${error.message}). Your feelings are still valid, and I'm still here with you in spirit. Please try again in a moment.`,
                        timestamp: new Date().toISOString()
                    };
                    setMessages(prev => [...prev, errorMessage]);
                    
                } finally {
                    setIsLoading(false);
                }
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                }
            };

            const handlePromptSuggestionClick = (suggestion) => {
                setInputText(suggestion);
                setShowPromptSuggestion(false);
                inputRef.current?.focus();
            };

            const handleFeedback = (messageIndex, feedbackType) => {
                StorageService.saveFeedback(sessionId, messageIndex, feedbackType);
                setShowFeedback(null);
                
                const feedbackMessages = {
                    'helpful': 'Thank you! I\'m glad that response resonated with you. üíô',
                    'confused': 'Thanks for the feedback. Would you like me to try explaining that differently, or approach it from another angle?',
                    'unhelpful': 'I appreciate your honesty. What would have been more helpful in that moment? I\'m here to learn and adapt.'
                };

                const feedbackMessage = {
                    type: 'system',
                    content: feedbackMessages[feedbackType],
                    timestamp: new Date().toISOString()
                };

                setMessages(prev => [...prev, feedbackMessage]);
            };

            const getCurrentPromptSuggestion = () => {
                const key = `${mood}-${mode}`;
                const suggestion = PROMPT_SUGGESTIONS[key];
                
                if (suggestion) {
                    return suggestion;
                }
                
                // Fallback suggestions based on mood only
                const moodFallbacks = {
                    'sad': "What's sitting heaviest on your heart right now?",
                    'anxious': "What thoughts keep circling through your mind?",
                    'angry': "What triggered this feeling, and what do you need most right now?",
                    'confused': "What decision or situation is feeling unclear?",
                    'overwhelmed': "What feels like too much to handle right now?",
                    'numb': "When did you last feel connected to your emotions?",
                    'joyful': "What's bringing you this positive energy?",
                    'frustrated': "What obstacle is in your way right now?",
                    'hopeful': "What's nurturing this sense of possibility?"
                };
                
                return moodFallbacks[mood] || "What's on your mind right now?";
            };

            const getCurrentModeDescription = () => {
                return MODES.find(m => m.value === mode)?.description || '';
            };

            const getStatusColor = () => {
                switch (connectionStatus) {
                    case 'connected': return '#28a745';
                    case 'sending': return '#ffc107';
                    case 'error': return '#dc3545';
                    default: return '#6c757d';
                }
            };

            return (
                <div className="app-container">
                    <div className="header">
                        <h1>üåü Emotion-Aware AI Chat</h1>
                        <p>Adaptive AI that responds to your emotional needs</p>
                    </div>

                    <div className="controls">
                        <div className="control-group">
                            <label>
                                <span className="mood-icon">{MOODS.find(m => m.value === mood)?.icon}</span>
                                Current Mood
                            </label>
                            <select 
                                value={mood} 
                                onChange={(e) => setMood(e.target.value)}
                                disabled={isLoading}
                            >
                                {MOODS.map(m => (
                                    <option key={m.value} value={m.value}>
                                        {m.icon} {m.label}
                                    </option>
                                ))}
                            </select>
                        </div>
                        
                        <div className="control-group">
                            <label>
                                <span className="mode-icon">{MODES.find(m => m.value === mode)?.icon}</span>
                                Response Mode
                            </label>
                            <select 
                                value={mode} 
                                onChange={(e) => setMode(e.target.value)}
                                disabled={isLoading}
                            >
                                {MODES.map(m => (
                                    <option key={m.value} value={m.value}>
                                        {m.icon} {m.label}
                                    </option>
                                ))}
                            </select>
                            <div className="mode-description">
                                {getCurrentModeDescription()}
                            </div>
                        </div>
                        
                        <button 
                            className="update-btn"
                            onClick={handleMoodModeChange}
                            disabled={isLoading}
                        >
                            <span>üîÑ</span>
                            Update Settings
                        </button>
                    </div>

                    <div className="chat-container">
                        <div className="chat-messages">
                            {messages.map((message, index) => (
                                <div key={index} className={`message ${message.type}`}>
                                    {message.content}
                                    
                                    {/* Show feedback buttons for AI messages */}
                                    {message.type === 'ai' && showFeedback === index && (
                                        <div className="feedback-container">
                                            <span className="feedback-label">Was this helpful?</span>
                                            <button 
                                                className="feedback-btn helpful"
                                                onClick={() => handleFeedback(index, 'helpful')}
                                            >
                                                <span>üëç</span> Helpful
                                            </button>
                                            <button 
                                                className="feedback-btn confused"
                                                onClick={() => handleFeedback(index, 'confused')}
                                            >
                                                <span>ü§î</span> Confused
                                            </button>
                                            <button 
                                                className="feedback-btn unhelpful"
                                                onClick={() => handleFeedback(index, 'unhelpful')}
                                            >
                                                <span>üëé</span> Not Helpful
                                            </button>
                                        </div>
                                    )}
                                </div>
                            ))}
                            
                            {/* Typing Indicator */}
                            {isLoading && (
                                <div className="typing-indicator">
                                    <span className="typing-text">Thinking</span>
                                    <div className="typing-dots">
                                        <div className="typing-dot"></div>
                                        <div className="typing-dot"></div>
                                        <div className="typing-dot"></div>
                                    </div>
                                </div>
                            )}
                            
                            <div ref={messagesEndRef} />
                        </div>

                        <div className="input-area">
                            {/* Prompt Suggestion */}
                            {showPromptSuggestion && (
                                <div 
                                    className="prompt-suggestion"
                                    onClick={() => handlePromptSuggestionClick(getCurrentPromptSuggestion())}
                                >
                                    <span>üí≠</span>
                                    <span>Suggestion: "{getCurrentPromptSuggestion()}"</span>
                                </div>
                            )}
                            
                            {/* Input Error */}
                            {inputError && (
                                <div className="message warning" style={{marginBottom: '15px'}}>
                                    ‚ö†Ô∏è {inputError}
                                </div>
                            )}
                            
                            <div className="input-container">
                                <div className="input-wrapper">
                                    <textarea
                                        ref={inputRef}
                                        value={inputText}
                                        onChange={(e) => setInputText(e.target.value)}
                                        onKeyPress={handleKeyPress}
                                        placeholder={`Share what's on your mind... (${2000 - inputText.length} characters left)`}
                                        disabled={isLoading}
                                        maxLength={2000}
                                    />
                                </div>
                                <button 
                                    className="send-btn"
                                    onClick={handleSendMessage}
                                    disabled={!inputText.trim() || isLoading || SafetyService.validateInput(inputText).length > 0}
                                >
                                    {isLoading ? (
                                        <>
                                            <span>‚è≥</span>
                                            Sending...
                                        </>
                                    ) : (
                                        <>
                                            <span>üíå</span>
                                            Send
                                        </>
                                    )}
                                </button>
                            </div>
                        </div>
                    </div>

                    <div className="status-bar">
                        <div className="status-left">
                            <div className="status-item">
                                <span style={{color: getStatusColor()}}>‚óè</span>
                                <span>
                                    {connectionStatus === 'connected' && 'Connected'}
                                    {connectionStatus === 'sending' && 'Sending...'}
                                    {connectionStatus === 'error' && 'Connection Issue'}
                                </span>
                            </div>
                            <div className="status-item">
                                <span>üé≠</span>
                                <span>{MODES.find(m => m.value === mode)?.label}</span>
                            </div>
                            <div className="status-item">
                                <span>{MOODS.find(m => m.value === mood)?.icon}</span>
                                <span>{MOODS.find(m => m.value === mood)?.label}</span>
                            </div>
                        </div>
                        <div>
                            <span>Session: {new Date().toLocaleTimeString()}</span>
                        </div>
                    </div>
                </div>
            );
        };

        // Render the app
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>